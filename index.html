<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slight LISP - Browser REPL</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', 'Consolas', monospace;
            background: #0a0a0a;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        .terminal-window {
            position: absolute;
            background: #000000;
            border: 1px solid #00aa00;
            border-radius: 2px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            min-width: 400px;
            min-height: 300px;
            display: flex;
            flex-direction: column;
            z-index: 1;
            resize: both;
            overflow: hidden;
        }

        .terminal-window.terminated {
            border-color: #cc0000;
        }

        .terminal-window.active {
            z-index: 1000;
            border-color: #00cc00;
        }

        .terminal-window.terminated.active {
            border-color: #ff0000;
        }

        .terminal-header {
            background: #0a0a0a;
            padding: 6px 10px;
            cursor: move;
            border-bottom: 1px solid #00aa00;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }

        .terminal-window.terminated .terminal-header {
            background: #0a0a0a;
            border-bottom-color: #cc0000;
        }

        .terminal-title {
            color: #00cc00;
            font-size: 13px;
            font-weight: normal;
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
        }

        .terminal-window.terminated .terminal-title {
            color: #cc0000;
        }

        .close-button {
            color: #cc0000;
            background: transparent;
            border: 1px solid #cc0000;
            padding: 2px 8px;
            cursor: pointer;
            font-size: 11px;
            border-radius: 2px;
            display: none;
        }

        .terminal-window.terminated .close-button {
            display: block;
        }

        .close-button:hover {
            background: #cc0000;
            color: #000;
        }

        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 20px;
            height: 20px;
            cursor: nwse-resize;
            z-index: 10;
        }

        .resize-handle::after {
            content: '';
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 12px;
            height: 12px;
            border-right: 2px solid #00aa00;
            border-bottom: 2px solid #00aa00;
        }

        .terminal-window.terminated .resize-handle::after {
            border-color: #cc0000;
        }

        .mailbox-indicator {
            font-size: 16px;
            display: none;
        }

        .mailbox-indicator.has-messages {
            display: inline;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .terminal-body {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .terminal-output {
            flex: 1;
            padding: 8px;
            overflow-y: auto;
            color: #00cc00;
            font-size: 13px;
            line-height: 1.3;
            display: flex;
            flex-direction: column-reverse;
        }

        .terminal-output-inner {
            display: flex;
            flex-direction: column;
        }

        .terminal-window.terminated .terminal-output {
            color: #cc0000;
        }

        .output-line {
            margin-bottom: 2px;
            word-wrap: break-word;
        }

        .output-line.prompt {
            color: #009900;
        }

        .output-line.result {
            color: #00cc00;
            margin-left: 16px;
        }

        .output-line.error {
            color: #dd6666;
            margin-left: 16px;
        }

        .output-line.info {
            color: #cc9900;
            font-style: italic;
        }

        .terminal-input-container {
            border-top: 1px solid #00aa00;
            display: flex;
            padding: 6px 8px;
            background: #0a0a0a;
        }

        .terminal-window.terminated .terminal-input-container {
            border-top-color: #cc0000;
        }

        .input-prompt {
            color: #009900;
            margin-right: 6px;
            user-select: none;
        }

        .terminal-input {
            flex: 1;
            background: transparent;
            border: none;
            color: #00cc00;
            font-family: inherit;
            font-size: 13px;
            outline: none;
        }

        .terminal-window.terminated .terminal-input {
            color: #666;
        }

        .terminal-input:disabled {
            cursor: not-allowed;
        }

        /* Scrollbar styling */
        .terminal-output::-webkit-scrollbar {
            width: 6px;
        }

        .terminal-output::-webkit-scrollbar-track {
            background: #000;
        }

        .terminal-output::-webkit-scrollbar-thumb {
            background: #00aa00;
            border-radius: 3px;
        }

        .terminal-window.terminated .terminal-output::-webkit-scrollbar-thumb {
            background: #cc0000;
        }

        .startup-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00cc00;
            font-size: 20px;
            text-align: center;
            animation: fadeOut 2s ease-out forwards;
        }

        @keyframes fadeOut {
            0% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="startup-message">SLIGHT LISP INITIALIZED</div>

    <script type="module">
        import { BrowserSlight, StringSource, ArrayOutput } from './js/src/browser.js';
        import { ProcessRuntime } from './js/src/Slight/ProcessRuntime.js';

        // Window manager to handle all terminal windows
        class WindowManager {
            constructor() {
                this.windows = new Map(); // pid -> window element and interpreter
                this.nextZIndex = 1000;
                this.processRuntime = ProcessRuntime.getInstance();

                // Override ProcessRuntime spawn to create windows
                this.interceptSpawn();

                // Create main window (PID 0)
                this.createWindow(0, null, 50, 50, false);
            }

            interceptSpawn() {
                const originalSpawn = this.processRuntime.spawn.bind(this.processRuntime);
                const self = this;

                this.processRuntime.spawn = async function(code, parentState) {
                    // Call original spawn
                    const pid = await originalSpawn(code, parentState);

                    // Get parent PID from the interpreter that called spawn
                    const parentPid = parentState ? (parentState._parentPid || 0) : 0;

                    // Position spawned window to the right or below main window
                    const parentWindow = self.windows.get(parentPid);
                    let x, y;

                    if (parentWindow) {
                        const parentEl = parentWindow.element;
                        const parentRect = parentEl.getBoundingClientRect();

                        // Try to place to the right
                        x = parentRect.right + 10;
                        y = parentRect.top;

                        // If too far right, place below
                        if (x + 450 > window.innerWidth) {
                            x = parentRect.left;
                            y = parentRect.bottom + 10;

                            // If too far down, cascade with offset
                            if (y + 300 > window.innerHeight) {
                                const offset = (self.windows.size - 1) * 30;
                                x = 50 + offset;
                                y = 50 + offset;
                            }
                        }
                    } else {
                        // Default positioning
                        const offset = self.windows.size * 30;
                        x = 50 + offset;
                        y = 50 + offset;
                    }

                    self.createWindow(pid, parentPid, x, y, pid > 0);

                    return pid;
                };
            }

            createWindow(pid, parentPid, x, y, isSpawned = false) {
                const windowEl = document.createElement('div');
                windowEl.className = 'terminal-window';
                windowEl.style.left = x + 'px';
                windowEl.style.top = y + 'px';

                // Spawned windows are smaller
                if (isSpawned) {
                    windowEl.style.width = '450px';
                    windowEl.style.height = '300px';
                } else {
                    windowEl.style.width = '600px';
                    windowEl.style.height = '450px';
                }

                const title = parentPid !== null
                    ? `PID: ${pid} (Parent: ${parentPid})`
                    : `PID: ${pid} (Main)`;

                windowEl.innerHTML = `
                    <div class="terminal-header">
                        <div class="terminal-title">
                            <span class="mailbox-indicator">📬</span>
                            <span>${title}</span>
                        </div>
                        <button class="close-button">✕ Close</button>
                    </div>
                    <div class="terminal-body">
                        <div class="terminal-output">
                            <div class="terminal-output-inner"></div>
                        </div>
                        <div class="terminal-input-container">
                            <span class="input-prompt">&gt;</span>
                            <input type="text" class="terminal-input" autofocus>
                        </div>
                    </div>
                    <div class="resize-handle"></div>
                `;

                document.body.appendChild(windowEl);

                // Make draggable
                this.makeDraggable(windowEl);

                // Make resizable
                this.makeResizable(windowEl);

                // Make active on click
                windowEl.addEventListener('mousedown', () => {
                    this.setActive(windowEl);
                });

                // Close button handler
                const closeBtn = windowEl.querySelector('.close-button');
                closeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    windowEl.remove();
                    this.windows.delete(pid);
                });

                // Create interpreter for this window
                const input = new StringSource('');
                const output = new ArrayOutput();
                const slight = new BrowserSlight(input, output);
                const interpreter = slight.getInterpreter();
                interpreter._processPid = pid;

                // Setup input handling
                const inputEl = windowEl.querySelector('.terminal-input');
                const outputInner = windowEl.querySelector('.terminal-output-inner');
                const mailboxIndicator = windowEl.querySelector('.mailbox-indicator');

                // Command history for this window
                const commandHistory = [];
                let historyIndex = -1;

                // Welcome message
                if (pid === 0) {
                    this.addOutput(outputInner, 'info', 'Welcome to Slight LISP Browser REPL');
                    this.addOutput(outputInner, 'info', '');
                    this.addOutput(outputInner, 'info', 'Try spawning a process that waits for messages:');
                    this.addOutput(outputInner, 'info', '  (def worker (fun () (begin (send 0 "Hello!") (recv))))');
                    this.addOutput(outputInner, 'info', '  (def pid (spawn worker))');
                    this.addOutput(outputInner, 'info', '');
                    this.addOutput(outputInner, 'info', 'Then receive and reply:');
                    this.addOutput(outputInner, 'info', '  (recv)');
                    this.addOutput(outputInner, 'info', '  (send pid "Reply!")');
                } else {
                    this.addOutput(outputInner, 'info', `Process ${pid} started`);
                }

                inputEl.addEventListener('keydown', async (e) => {
                    // Handle history navigation
                    if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        if (commandHistory.length > 0) {
                            if (historyIndex === -1) {
                                historyIndex = commandHistory.length - 1;
                            } else if (historyIndex > 0) {
                                historyIndex--;
                            }
                            inputEl.value = commandHistory[historyIndex];
                        }
                        return;
                    } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        if (historyIndex !== -1) {
                            historyIndex++;
                            if (historyIndex >= commandHistory.length) {
                                historyIndex = -1;
                                inputEl.value = '';
                            } else {
                                inputEl.value = commandHistory[historyIndex];
                            }
                        }
                        return;
                    }

                    if (e.key === 'Enter') {
                        const code = inputEl.value.trim();
                        if (code) {
                            // Add to history
                            commandHistory.push(code);
                            historyIndex = -1;

                            // Show input
                            this.addOutput(outputInner, 'prompt', `> ${code}`);
                            inputEl.value = '';

                            // Evaluate
                            try {
                                const input = new StringSource(code);
                                const output = new ArrayOutput();
                                const slight = new BrowserSlight(input, output);

                                // Copy current interpreter state
                                slight.interpreter.functions = interpreter.functions;
                                slight.interpreter.macros = interpreter.macros;
                                slight.interpreter.bindings = interpreter.bindings;
                                slight.interpreter._processPid = pid;

                                await slight.run();

                                // Update interpreter state
                                interpreter.functions = slight.interpreter.functions;
                                interpreter.macros = slight.interpreter.macros;
                                interpreter.bindings = slight.interpreter.bindings;

                                // Display results
                                if (output.errors.length > 0) {
                                    output.errors.forEach(err => {
                                        const msg = err.message || err;
                                        this.addOutput(outputInner, 'error', `Error: ${msg}`);
                                    });
                                } else if (output.results.length > 0) {
                                    output.results.forEach(result => {
                                        this.addOutput(outputInner, 'result', this.formatValue(result));
                                    });
                                } else {
                                    this.addOutput(outputInner, 'info', '(no output)');
                                }
                            } catch (error) {
                                this.addOutput(outputInner, 'error', `Error: ${error.message}`);
                            }
                        }
                    }
                });

                // Store window info
                this.windows.set(pid, {
                    element: windowEl,
                    interpreter,
                    outputInner,
                    inputEl,
                    mailboxIndicator
                });

                // Set as active
                this.setActive(windowEl);

                // Poll for messages
                this.pollMessages(pid);

                // Check if process is alive
                this.monitorProcess(pid);
            }

            async pollMessages(pid) {
                const window = this.windows.get(pid);
                if (!window) return;

                // Check mailbox size periodically
                const checkMailbox = () => {
                    if (!this.windows.has(pid)) return;

                    const handle = this.processRuntime['processes'].get(pid);
                    if (!handle || !handle.mailbox) {
                        setTimeout(checkMailbox, 100);
                        return;
                    }

                    const queueSize = handle.mailbox['queue'] ? handle.mailbox['queue'].length : 0;
                    if (queueSize > 0) {
                        window.mailboxIndicator.classList.add('has-messages');
                    } else {
                        window.mailboxIndicator.classList.remove('has-messages');
                    }

                    setTimeout(checkMailbox, 100);
                };

                checkMailbox();
            }

            async monitorProcess(pid) {
                if (pid === 0) return; // Main process never dies

                const checkStatus = () => {
                    if (!this.windows.has(pid)) return;

                    const isAlive = this.processRuntime.isAlive(pid);
                    const window = this.windows.get(pid);

                    if (!isAlive && !window.element.classList.contains('terminated')) {
                        window.element.classList.add('terminated');
                        window.inputEl.disabled = true;
                        this.addOutput(window.outputInner, 'error', '[PROCESS TERMINATED]');
                        return;
                    }

                    setTimeout(checkStatus, 100);
                };

                setTimeout(checkStatus, 100);
            }

            addOutput(outputInner, type, text) {
                const line = document.createElement('div');
                line.className = `output-line ${type}`;
                line.textContent = text;
                outputInner.appendChild(line);
            }

            formatValue(value) {
                if (value === null) return 'null';
                if (value === undefined) return 'undefined';
                if (typeof value === 'string') return `"${value}"`;
                if (Array.isArray(value)) {
                    return '(' + value.map(v => this.formatValue(v)).join(' ') + ')';
                }
                if (typeof value === 'object' && value.params && value.body) {
                    return `<function>`;
                }
                return String(value);
            }

            makeDraggable(element) {
                const header = element.querySelector('.terminal-header');
                let isDragging = false;
                let currentX;
                let currentY;
                let initialX;
                let initialY;

                header.addEventListener('mousedown', (e) => {
                    if (e.target === header || e.target.closest('.terminal-title')) {
                        initialX = e.clientX - element.offsetLeft;
                        initialY = e.clientY - element.offsetTop;
                        isDragging = true;
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        e.preventDefault();
                        currentX = e.clientX - initialX;
                        currentY = e.clientY - initialY;

                        element.style.left = currentX + 'px';
                        element.style.top = currentY + 'px';
                    }
                });

                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });
            }

            makeResizable(element) {
                const resizeHandle = element.querySelector('.resize-handle');
                let isResizing = false;
                let startX, startY, startWidth, startHeight;

                resizeHandle.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    isResizing = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    startWidth = parseInt(getComputedStyle(element).width, 10);
                    startHeight = parseInt(getComputedStyle(element).height, 10);
                });

                document.addEventListener('mousemove', (e) => {
                    if (isResizing) {
                        e.preventDefault();
                        const width = startWidth + (e.clientX - startX);
                        const height = startHeight + (e.clientY - startY);

                        if (width > 400) {
                            element.style.width = width + 'px';
                        }
                        if (height > 300) {
                            element.style.height = height + 'px';
                        }
                    }
                });

                document.addEventListener('mouseup', () => {
                    isResizing = false;
                });
            }

            setActive(element) {
                // Remove active from all windows
                document.querySelectorAll('.terminal-window').forEach(w => {
                    w.classList.remove('active');
                    w.style.zIndex = 1;
                });

                // Set active
                element.classList.add('active');
                element.style.zIndex = this.nextZIndex++;

                // Focus input
                const input = element.querySelector('.terminal-input');
                if (input) input.focus();
            }
        }

        // Initialize window manager
        window.windowManager = new WindowManager();
    </script>
</body>
</html>
